
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../PruningMethod/">
      
      
        <link rel="next" href="../ShrinkStrategy/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.3">
    
    
      
        <title>SearchAlgorithm - Plugins</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.79e020e9.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a_search_eager" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Plugins" class="md-header__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Plugins
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SearchAlgorithm
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Plugins" class="md-nav__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Plugins
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../AbstractTask/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AbstractTask
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../AbstractionGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AbstractionGenerator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../ConstraintGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ConstraintGenerator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Evaluator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Evaluator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../LabelReduction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LabelReduction
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../LandmarkFactory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LandmarkFactory
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../MergeScoringFunction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MergeScoringFunction
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../MergeSelector/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MergeSelector
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../MergeStrategy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MergeStrategy
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../MergeTree/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MergeTree
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../OpenList/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OpenList
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../OrderGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OrderGenerator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../PatternCollectionGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PatternCollectionGenerator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../PatternGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PatternGenerator
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../PruningMethod/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PruningMethod
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    SearchAlgorithm
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    SearchAlgorithm
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a_search_eager" class="md-nav__link">
    A* search (eager)
  </a>
  
    <nav class="md-nav" aria-label="A* search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#breadth-first_search" class="md-nav__link">
    Breadth-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depth-first_search" class="md-nav__link">
    Depth-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exhaustive_search" class="md-nav__link">
    Exhaustive search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_best-first_search" class="md-nav__link">
    Eager best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_eager" class="md-nav__link">
    Greedy search (eager)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search_1" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_weighted_a_search" class="md-nav__link">
    Eager weighted A* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_enforced_hill-climbing" class="md-nav__link">
    Lazy enforced hill-climbing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ida_search" class="md-nav__link">
    IDA* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterative_deepening_search" class="md-nav__link">
    Iterative deepening search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_search" class="md-nav__link">
    Iterated search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_width_search" class="md-nav__link">
    Iterated width search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_best-first_search" class="md-nav__link">
    Lazy best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_lazy" class="md-nav__link">
    Greedy search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted_a_search_lazy" class="md-nav__link">
    (Weighted) A* search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="(Weighted) A* search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search_1" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../ShrinkStrategy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ShrinkStrategy
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../SubtaskGenerator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SubtaskGenerator
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a_search_eager" class="md-nav__link">
    A* search (eager)
  </a>
  
    <nav class="md-nav" aria-label="A* search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#breadth-first_search" class="md-nav__link">
    Breadth-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depth-first_search" class="md-nav__link">
    Depth-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exhaustive_search" class="md-nav__link">
    Exhaustive search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_best-first_search" class="md-nav__link">
    Eager best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_eager" class="md-nav__link">
    Greedy search (eager)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search_1" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_weighted_a_search" class="md-nav__link">
    Eager weighted A* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_enforced_hill-climbing" class="md-nav__link">
    Lazy enforced hill-climbing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ida_search" class="md-nav__link">
    IDA* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterative_deepening_search" class="md-nav__link">
    Iterative deepening search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_search" class="md-nav__link">
    Iterated search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_width_search" class="md-nav__link">
    Iterated width search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_best-first_search" class="md-nav__link">
    Lazy best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_lazy" class="md-nav__link">
    Greedy search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted_a_search_lazy" class="md-nav__link">
    (Weighted) A* search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="(Weighted) A* search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search_1" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>SearchAlgorithm</h1>

<h2 id="a_search_eager">A* search (eager)<a class="headerlink" href="#a_search_eager" title="Permanent link">#</a></h2>
<p>A* is a special case of eager best first search that uses g+h as f-function. We break ties using the evaluator. Closed nodes are re-opened.</p>
<pre><code>astar(eval, lazy_evaluator=&lt;none&gt;, pruning=null(), cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>eval</em> (<a href="../Evaluator/">Evaluator</a>): evaluator for h-value</li>
<li><em>lazy_evaluator</em> (<a href="../Evaluator/">Evaluator</a>): An evaluator that re-evaluates a state before it is expanded.</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>lazy_evaluator:</strong> When a state s is taken out of the open list, the lazy evaluator h re-evaluates s. If h(s) changes (for example because h is path-dependent), s is not expanded, but instead reinserted into the open list. This option is currently only present for the A* algorithm.</p>
<h3 id="equivalent_statements_using_general_eager_search">Equivalent statements using general eager search<a class="headerlink" href="#equivalent_statements_using_general_eager_search" title="Permanent link">#</a></h3>
<pre><code>--search astar(evaluator)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h=evaluator
--search eager(tiebreaking([sum([g(), h]), h], unsafe_pruning=false),
               reopen_closed=true, f_eval=sum([g(), h]))
</code></pre>
<h2 id="breadth-first_search">Breadth-first search<a class="headerlink" href="#breadth-first_search" title="Permanent link">#</a></h2>
<p>Breadth-first graph search.</p>
<pre><code>brfs(single_plan=true, write_plan=true, pruning=null(), verbosity=normal)
</code></pre>
<ul>
<li><em>single_plan</em> (bool): Stop search after finding the first (shortest) plan.</li>
<li><em>write_plan</em> (bool): Store the necessary information during search for writing plans once they're found.</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="depth-first_search">Depth-first search<a class="headerlink" href="#depth-first_search" title="Permanent link">#</a></h2>
<p>This is a depth-first tree search that avoids running in cycles by skipping states s that are already visited earlier on the path to s. Doing so, the search becomes complete.</p>
<pre><code>dfs(single_plan=false, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>single_plan</em> (bool): stop after finding the first plan</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="exhaustive_search">Exhaustive search<a class="headerlink" href="#exhaustive_search" title="Permanent link">#</a></h2>
<p>Dump the reachable state space.</p>
<pre><code>dump_reachable_search_space(verbosity=normal)
</code></pre>
<ul>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="eager_best-first_search">Eager best-first search<a class="headerlink" href="#eager_best-first_search" title="Permanent link">#</a></h2>
<pre><code>eager(open, reopen_closed=false, f_eval=&lt;none&gt;, preferred=[], pruning=null(), cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>open</em> (<a href="../OpenList/">OpenList</a>): open list</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>f_eval</em> (<a href="../Evaluator/">Evaluator</a>): set evaluator for jump statistics. (Optional; if no evaluator is used, jump statistics will not be displayed.)</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="greedy_search_eager">Greedy search (eager)<a class="headerlink" href="#greedy_search_eager" title="Permanent link">#</a></h2>
<pre><code>eager_greedy(evals, preferred=[], boost=0, pruning=null(), cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Open list:</strong> In most cases, eager greedy best first search uses an alternation open list with one queue for each evaluator. If preferred operator evaluators are used, it adds an extra queue for each of these evaluators that includes only the nodes that are generated with a preferred operator. If only one evaluator and no preferred operator evaluator is used, the search does not use an alternation open list but a standard open list with only one queue.</p>
<p><strong>Closed nodes:</strong> Closed node are not re-opened</p>
<h3 id="equivalent_statements_using_general_eager_search_1">Equivalent statements using general eager search<a class="headerlink" href="#equivalent_statements_using_general_eager_search_1" title="Permanent link">#</a></h3>
<pre><code>--evaluator h2=eval2
--search eager_greedy([eval1, h2], preferred=h2, boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search eager(alt([single(h1), single(h1, pref_only=true), single(h2), 
                    single(h2, pref_only=true)], boost=100),
               preferred=h2)
</code></pre>
<hr />
<pre><code>--search eager_greedy([eval1, eval2])
</code></pre>
<p>is equivalent to</p>
<pre><code>--search eager(alt([single(eval1), single(eval2)]))
</code></pre>
<hr />
<pre><code>--evaluator h1=eval1
--search eager_greedy(h1, preferred=h1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1
--search eager(alt([single(h1), single(h1, pref_only=true)]),
               preferred=h1)
</code></pre>
<hr />
<pre><code>--search eager_greedy(eval1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search eager(single(eval1))
</code></pre>
<h2 id="eager_weighted_a_search">Eager weighted A* search<a class="headerlink" href="#eager_weighted_a_search" title="Permanent link">#</a></h2>
<pre><code>eager_wastar(evals, preferred=[], reopen_closed=true, boost=0, w=1, pruning=null(), cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>w</em> (int): evaluator weight</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Open lists and equivalent statements using general eager search:</strong> See corresponding notes for "(Weighted) A* search (lazy)"</p>
<p><strong>Note:</strong> Eager weighted A<em> search uses an alternation open list while A</em> search uses a tie-breaking open list. Consequently, </p>
<pre><code>--search eager_wastar([h()], w=1)
</code></pre>
<p>is <strong>not</strong> equivalent to</p>
<pre><code>--search astar(h())
</code></pre>
<h2 id="lazy_enforced_hill-climbing">Lazy enforced hill-climbing<a class="headerlink" href="#lazy_enforced_hill-climbing" title="Permanent link">#</a></h2>
<pre><code>ehc(h, preferred_usage=prune_by_preferred, preferred=[], cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>h</em> (<a href="../Evaluator/">Evaluator</a>): heuristic</li>
<li><em>preferred_usage</em> ({prune_by_preferred, rank_preferred_first}): preferred operator usage</li>
<li><code>prune_by_preferred</code>: prune successors achieved by non-preferred operators</li>
<li><code>rank_preferred_first</code>: first insert successors achieved by preferred operators, then those by non-preferred operators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="ida_search">IDA* search<a class="headerlink" href="#ida_search" title="Permanent link">#</a></h2>
<p>IDA* search with an optional g-value cache.</p>
<pre><code>idastar(eval, initial_f_limit=0, cache_size=0, single_plan=true, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>eval</em> (<a href="../Evaluator/">Evaluator</a>): evaluator for h-value. Make sure to use cache_estimates=false.</li>
<li><em>initial_f_limit</em> (int [0, infinity]): initial depth limit</li>
<li><em>cache_size</em> (int [0, infinity]): maximum number of states to cache. For cache_size=infinity the cache fills up until approaching the memory limit, at which point the current number of states becomes the maximum cache size.</li>
<li><em>single_plan</em> (bool): stop after finding the first plan</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="iterative_deepening_search">Iterative deepening search<a class="headerlink" href="#iterative_deepening_search" title="Permanent link">#</a></h2>
<pre><code>ids(single_plan=true, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>single_plan</em> (bool): stop after finding the first (shortest) plan</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="iterated_search">Iterated search<a class="headerlink" href="#iterated_search" title="Permanent link">#</a></h2>
<pre><code>iterated(algorithm_configs, pass_bound=true, repeat_last=false, continue_on_fail=false, continue_on_solve=true, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>algorithm_configs</em> (list of <a href="./">SearchAlgorithm</a>): list of search algorithms for each phase</li>
<li><em>pass_bound</em> (bool): use bound from previous search. The bound is the real cost of the plan found before, regardless of the cost_type parameter.</li>
<li><em>repeat_last</em> (bool): repeat last phase of search</li>
<li><em>continue_on_fail</em> (bool): continue search after no solution found</li>
<li><em>continue_on_solve</em> (bool): continue search after solution found</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Note 1:</strong> We don't cache heuristic values between search iterations at the moment. If you perform a LAMA-style iterative search, heuristic values will be computed multiple times.</p>
<p><strong>Note 2:</strong> The configuration</p>
<pre><code>--search "iterated([lazy_wastar([ipdb()],w=10), lazy_wastar([ipdb()],w=5), lazy_wastar([ipdb()],w=3), lazy_wastar([ipdb()],w=2), lazy_wastar([ipdb()],w=1)])"
</code></pre>
<p>would perform the preprocessing phase of the ipdb heuristic 5 times (once before each iteration).</p>
<p>To avoid this, use heuristic predefinition, which avoids duplicate preprocessing, as follows:</p>
<pre><code>--evaluator "h=ipdb()" --search "iterated([lazy_wastar([h],w=10), lazy_wastar([h],w=5), lazy_wastar([h],w=3), lazy_wastar([h],w=2), lazy_wastar([h],w=1)])"
</code></pre>
<p><strong>Note 3:</strong> If you reuse the same landmark count heuristic (using heuristic predefinition) between iterations, the path data (that is, landmark status for each visited state) will be saved between iterations.</p>
<h2 id="iterated_width_search">Iterated width search<a class="headerlink" href="#iterated_width_search" title="Permanent link">#</a></h2>
<pre><code>iw(width=2, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>width</em> (int [1, 2]): maximum conjunction size</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<h2 id="lazy_best-first_search">Lazy best-first search<a class="headerlink" href="#lazy_best-first_search" title="Permanent link">#</a></h2>
<pre><code>lazy(open, reopen_closed=false, preferred=[], randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>open</em> (<a href="../OpenList/">OpenList</a>): open list</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
<h2 id="greedy_search_lazy">Greedy search (lazy)<a class="headerlink" href="#greedy_search_lazy" title="Permanent link">#</a></h2>
<pre><code>lazy_greedy(evals, preferred=[], reopen_closed=false, boost=1000, randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for alternation queues that are restricted to preferred operator nodes</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
<p><strong>Open lists:</strong> In most cases, lazy greedy best first search uses an alternation open list with one queue for each evaluator. If preferred operator evaluators are used, it adds an extra queue for each of these evaluators that includes only the nodes that are generated with a preferred operator. If only one evaluator and no preferred operator evaluator is used, the search does not use an alternation open list but a standard open list with only one queue.</p>
<h3 id="equivalent_statements_using_general_lazy_search">Equivalent statements using general lazy search<a class="headerlink" href="#equivalent_statements_using_general_lazy_search" title="Permanent link">#</a></h3>
<pre><code>--evaluator h2=eval2
--search lazy_greedy([eval1, h2], preferred=h2, boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search lazy(alt([single(h1), single(h1, pref_only=true), single(h2),
                  single(h2, pref_only=true)], boost=100),
              preferred=h2)
</code></pre>
<hr />
<pre><code>--search lazy_greedy([eval1, eval2], boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(eval1), single(eval2)], boost=100))
</code></pre>
<hr />
<pre><code>--evaluator h1=eval1
--search lazy_greedy(h1, preferred=h1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1
--search lazy(alt([single(h1), single(h1, pref_only=true)], boost=1000),
              preferred=h1)
</code></pre>
<hr />
<pre><code>--search lazy_greedy(eval1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(single(eval1))
</code></pre>
<h2 id="weighted_a_search_lazy">(Weighted) A* search (lazy)<a class="headerlink" href="#weighted_a_search_lazy" title="Permanent link">#</a></h2>
<p>Weighted A* is a special case of lazy best first search.</p>
<pre><code>lazy_wastar(evals, preferred=[], reopen_closed=true, boost=1000, w=1, randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=normal, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>w</em> (int): evaluator weight</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({normal, one, plusone}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.</li>
<li><code>normal</code>: all actions are accounted for with their real cost</li>
<li><code>one</code>: all actions are accounted for as unit cost</li>
<li><code>plusone</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search algorithms, but is supported for both.</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
<p><strong>Open lists:</strong> In the general case, it uses an alternation open list with one queue for each evaluator h that ranks the nodes by g + w * h. If preferred operator evaluators are used, it adds for each of the evaluators another such queue that only inserts nodes that are generated by preferred operators. In the special case with only one evaluator and no preferred operator evaluators, it uses a single queue that is ranked by g + w * h. </p>
<h3 id="equivalent_statements_using_general_lazy_search_1">Equivalent statements using general lazy search<a class="headerlink" href="#equivalent_statements_using_general_lazy_search_1" title="Permanent link">#</a></h3>
<pre><code>--evaluator h1=eval1
--search lazy_wastar([h1, eval2], w=2, preferred=h1,
                     bound=100, boost=500)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search lazy(alt([single(sum([g(), weight(h1, 2)])),
                   single(sum([g(), weight(h1, 2)]), pref_only=true),
                   single(sum([g(), weight(h2, 2)])),
                   single(sum([g(), weight(h2, 2)]), pref_only=true)],
                  boost=500),
              preferred=h1, reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar([eval1, eval2], w=2, bound=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(sum([g(), weight(eval1, 2)])),
                   single(sum([g(), weight(eval2, 2)]))],
                  boost=1000),
              reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar([eval1, eval2], bound=100, boost=0)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(sum([g(), eval1])),
                   single(sum([g(), eval2]))])
              reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar(eval1, w=2)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(single(sum([g(), weight(eval1, 2)])), reopen_closed=true)
</code></pre>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.a264c092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.6eac0284.min.js"></script>
      
    
  </body>
</html>