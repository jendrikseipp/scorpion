
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.3.0">
    
    
      
        <title>Evaluator - Plugins</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8b42a75e.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#additive_heuristic" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Plugins" class="md-header__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Plugins
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Evaluator
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Plugins" class="md-nav__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Plugins
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../AbstractTask/" class="md-nav__link">
        AbstractTask
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../AbstractionGenerator/" class="md-nav__link">
        AbstractionGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ConstraintGenerator/" class="md-nav__link">
        ConstraintGenerator
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Evaluator
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Evaluator
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#additive_heuristic" class="md-nav__link">
    Additive heuristic
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../LabelReduction/" class="md-nav__link">
        LabelReduction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../LandmarkFactory/" class="md-nav__link">
        LandmarkFactory
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeScoringFunction/" class="md-nav__link">
        MergeScoringFunction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeSelector/" class="md-nav__link">
        MergeSelector
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeStrategy/" class="md-nav__link">
        MergeStrategy
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeTree/" class="md-nav__link">
        MergeTree
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../OpenList/" class="md-nav__link">
        OpenList
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../OrderGenerator/" class="md-nav__link">
        OrderGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PatternCollectionGenerator/" class="md-nav__link">
        PatternCollectionGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PatternGenerator/" class="md-nav__link">
        PatternGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PruningMethod/" class="md-nav__link">
        PruningMethod
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../SearchAlgorithm/" class="md-nav__link">
        SearchAlgorithm
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ShrinkStrategy/" class="md-nav__link">
        ShrinkStrategy
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../SubtaskGenerator/" class="md-nav__link">
        SubtaskGenerator
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#additive_heuristic" class="md-nav__link">
    Additive heuristic
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>Evaluator</h1>
                
                <p>An evaluator specification is either a newly created evaluator instance or an evaluator that has been defined previously. This page describes how one can specify a new evaluator instance. For re-using evaluators, see OptionSyntax#Evaluator_Predefinitions.</p>
<p>If the evaluator is a heuristic, definitions of <em>properties</em> in the descriptions below:</p>
<ul>
<li><strong>admissible:</strong> h(s) &lt;= h*(s) for all states s</li>
<li><strong>consistent:</strong> h(s) &lt;= c(s, s') + h(s') for all states s connected to states s' by an action with cost c(s, s')</li>
<li><strong>safe:</strong> h(s) = infinity is only true for states with h*(s) = infinity</li>
<li><strong>preferred operators:</strong> this heuristic identifies preferred operators </li>
</ul>
<p>This feature type can be bound to variables using <code>let(variable_name, variable_definition, expression)</code> where <code>expression</code> can use <code>variable_name</code>. Predefinitions using <code>--evaluator</code>, <code>--heuristic</code>, and <code>--landmarks</code> are automatically transformed into <code>let</code>-expressions but are deprecated.</p>
<h2 id="additive_heuristic">Additive heuristic<a class="headerlink" href="#additive_heuristic" title="Permanent link">#</a></h2>
<pre><code>add(verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported (in the sense that the planner won't complain -- handling of axioms might be very stupid and even render the heuristic unsafe)
Properties:</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> yes for tasks without axioms</li>
<li>
<p><strong>preferred operators:</strong> yes
== Blind heuristic ==
Returns cost of cheapest action for non-goal states, 0 for goal states
    blind(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Context-enhanced additive heuristic ==
    cea(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported (in the sense that the planner won't complain -- handling of axioms might be very stupid and even render the heuristic unsafe)
Properties:</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> no</li>
<li><strong>preferred operators:</strong> yes
== Additive Cartesian CEGAR heuristic ==
See the paper introducing counterexample-guided Cartesian abstraction refinement (CEGAR) for classical planning:</li>
</ul>
<p>Jendrik Seipp and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-helmert-icaps2013.pdf">Counterexample-guided Cartesian Abstraction Refinement</a>.<br />
In <em>Proceedings of the 23rd International Conference on Automated Planning and Scheduling (ICAPS 2013)</em>, pp. 347-351. AAAI Press, 2013.</p>
<p>and the paper showing how to make the abstractions additive:</p>
<p>Jendrik Seipp and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/seipp-helmert-icaps2014.pdf">Diverse and Additive Cartesian Abstraction Heuristics</a>.<br />
 In <em>Proceedings of the 24th International Conference on Automated Planning and Scheduling (ICAPS 2014)</em>, pp. 289-297. AAAI Press, 2014.</p>
<p>For more details on Cartesian CEGAR and saturated cost partitioning, see the journal paper</p>
<p>Jendrik Seipp and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/seipp-helmert-jair2018.pdf">Counterexample-Guided Cartesian Abstraction Refinement for Classical Planning</a>.<br />
 <em>Journal of Artificial Intelligence Research</em> 62:535-577. 2018.</p>
<p>For a description of the incremental search, see the paper</p>
<p>Jendrik Seipp, Samuel von Allmen and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-icaps2020.pdf">Incremental Search for Counterexample-Guided Cartesian Abstraction Refinement</a>.<br />
 In <em>Proceedings of the 30th International Conference on Automated Planning and Scheduling (ICAPS 2020)</em>, pp. 244-248. AAAI Press, 2020.</p>
<p>Finally, we describe advanced flaw selection strategies here:</p>
<p>David Speck and Jendrik Seipp.<br />
 <a href="https://jendrikseipp.com/papers/speck-seipp-icaps2022.pdf">New Refinement Strategies for Cartesian Abstractions</a>.<br />
 In <em>Proceedings of the 32nd International Conference on Automated Planning and Scheduling (ICAPS 2022)</em>, pp. to appear. AAAI Press, 2022.</p>
<pre><code>cegar(subtasks=[landmarks(order=random), goals(order=random)], max_states=infinity, max_transitions=1M, max_time=infinity, pick_flawed_abstract_state=batch_min_h, pick_split=max_cover, tiebreak_split=max_refined, memory_padding=500, dot_graph_verbosity=silent, random_seed=-1, max_concrete_states_per_abstract_state=infinity, max_state_expansions=1M, use_general_costs=true, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>subtasks</em> (list of <a href="../SubtaskGenerator/">SubtaskGenerator</a>): subtask generators</li>
<li><em>max_states</em> (int [1, infinity]): maximum sum of abstract states over all abstractions</li>
<li><em>max_transitions</em> (int [0, infinity]): maximum sum of state-changing transitions (excluding self-loops) over all abstractions</li>
<li><em>max_time</em> (double [0.0, infinity]): maximum time in seconds for building abstractions</li>
<li><em>pick_flawed_abstract_state</em> ({first, first_on_shortest_path, random, min_h, max_h, batch_min_h}): flaw-selection strategy</li>
<li><code>first</code>: Consider first encountered flawed abstract state and a random concrete state.</li>
<li><code>first_on_shortest_path</code>: Follow the arbitrary solution in the shortest path tree (no flaw search). Consider first encountered flawed abstract state and a random concrete state.</li>
<li><code>random</code>: Collect all flawed abstract states and then consider a random abstract state and a random concrete state.</li>
<li><code>min_h</code>: Collect all flawed abstract states and then consider a random abstract state with minimum h value and a random concrete state.</li>
<li><code>max_h</code>: Collect all flawed abstract states and then consider a random abstract state with maximum h value and a random concrete state.</li>
<li><code>batch_min_h</code>: Collect all flawed abstract states and iteratively refine them (by increasing h value). Only start a new flaw search once all remaining flawed abstract states are refined. For each abstract state consider all concrete states.</li>
<li><em>pick_split</em> ({random, min_unwanted, max_unwanted, min_refined, max_refined, min_hadd, max_hadd, min_cg, max_cg, max_cover}): split-selection strategy</li>
<li><code>random</code>: select a random variable (among all eligible variables)</li>
<li><code>min_unwanted</code>: select an eligible variable which has the least unwanted values (number of values of v that land in the abstract state whose h-value will probably be raised) in the flaw state</li>
<li><code>max_unwanted</code>: select an eligible variable which has the most unwanted values (number of values of v that land in the abstract state whose h-value will probably be raised) in the flaw state</li>
<li><code>min_refined</code>: select an eligible variable which is the least refined (-1 * (remaining_values(v) / original_domain_size(v))) in the flaw state</li>
<li><code>max_refined</code>: select an eligible variable which is the most refined (-1 * (remaining_values(v) / original_domain_size(v))) in the flaw state</li>
<li><code>min_hadd</code>: select an eligible variable with minimal h^add(s_0) value over all facts that need to be removed from the flaw state</li>
<li><code>max_hadd</code>: select an eligible variable with maximal h^add(s_0) value over all facts that need to be removed from the flaw state</li>
<li><code>min_cg</code>: order by increasing position in partial ordering of causal graph</li>
<li><code>max_cg</code>: order by decreasing position in partial ordering of causal graph</li>
<li><code>max_cover</code>: compute split that covers the maximum number of flaws for several concrete states.</li>
<li><em>tiebreak_split</em> ({random, min_unwanted, max_unwanted, min_refined, max_refined, min_hadd, max_hadd, min_cg, max_cg, max_cover}): split-selection strategy for breaking ties</li>
<li><code>random</code>: select a random variable (among all eligible variables)</li>
<li><code>min_unwanted</code>: select an eligible variable which has the least unwanted values (number of values of v that land in the abstract state whose h-value will probably be raised) in the flaw state</li>
<li><code>max_unwanted</code>: select an eligible variable which has the most unwanted values (number of values of v that land in the abstract state whose h-value will probably be raised) in the flaw state</li>
<li><code>min_refined</code>: select an eligible variable which is the least refined (-1 * (remaining_values(v) / original_domain_size(v))) in the flaw state</li>
<li><code>max_refined</code>: select an eligible variable which is the most refined (-1 * (remaining_values(v) / original_domain_size(v))) in the flaw state</li>
<li><code>min_hadd</code>: select an eligible variable with minimal h^add(s_0) value over all facts that need to be removed from the flaw state</li>
<li><code>max_hadd</code>: select an eligible variable with maximal h^add(s_0) value over all facts that need to be removed from the flaw state</li>
<li><code>min_cg</code>: order by increasing position in partial ordering of causal graph</li>
<li><code>max_cg</code>: order by decreasing position in partial ordering of causal graph</li>
<li><code>max_cover</code>: compute split that covers the maximum number of flaws for several concrete states.</li>
<li><em>memory_padding</em> (int [0, infinity]): amount of extra memory in MB to reserve for recovering from out-of-memory situations gracefully. When the memory runs out, we stop refining and start the search. Due to memory fragmentation, the memory used for building the abstraction (states, transitions, etc.) often can't be reused for things that require big continuous blocks of memory. It is for this reason that we require a rather large amount of memory padding by default.</li>
<li><em>dot_graph_verbosity</em> ({silent, write_to_console, write_to_file}): verbosity of printing/writing dot graphs</li>
<li><code>silent</code>: </li>
<li><code>write_to_console</code>: </li>
<li><code>write_to_file</code>: </li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>max_concrete_states_per_abstract_state</em> (int [1, infinity]): maximum number of flawed concrete states stored per abstract state</li>
<li><em>max_state_expansions</em> (int [1, infinity]): maximum number of state expansions per flaw search</li>
<li><em>use_general_costs</em> (bool): allow negative costs in cost partitioning</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Causal graph heuristic ==
    cg(max_cache_size=1000000, verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>max_cache_size</em> (int [0, infinity]): maximum number of cached entries per variable (set to 0 to disable cache)</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported (in the sense that the planner won't complain -- handling of axioms might be very stupid and even render the heuristic unsafe)
Properties:</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> no</li>
<li>
<p><strong>preferred operators:</strong> yes
== FF heuristic ==
    ff(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported (in the sense that the planner won't complain -- handling of axioms might be very stupid and even render the heuristic unsafe)
Properties:</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> yes for tasks without axioms</li>
<li>
<p><strong>preferred operators:</strong> yes
== Goal count heuristic ==
    goalcount(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> ignored by design</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported
Properties:</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== h^m heuristic ==
    hm(m=2, verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>m</em> (int [1, infinity]): subset size</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> ignored</li>
<li><strong>axioms:</strong> ignored
Properties:</li>
<li><strong>admissible:</strong> yes for tasks without conditional effects or axioms</li>
<li><strong>consistent:</strong> yes for tasks without conditional effects or axioms</li>
<li><strong>safe:</strong> yes for tasks without conditional effects or axioms</li>
<li>
<p><strong>preferred operators:</strong> no
== Max heuristic ==
    hmax(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported</li>
<li><strong>axioms:</strong> supported (in the sense that the planner won't complain -- handling of axioms might be very stupid and even render the heuristic unsafe)
Properties:</li>
<li><strong>admissible:</strong> yes for tasks without axioms</li>
<li><strong>consistent:</strong> yes for tasks without axioms</li>
<li><strong>safe:</strong> yes for tasks without axioms</li>
<li><strong>preferred operators:</strong> no
== Landmark cost partitioning heuristic ==
Landmark progression is implemented according to the following paper:</li>
</ul>
<p>Clemens Büchner, Thomas Keller, Salomé Eriksson and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/buechner-et-al-icaps2023.pdf">Landmarks Progression in Heuristic Search</a>.<br />
In <em>Proceedings of the Thirty-Third International Conference on Automated Planning and Scheduling (ICAPS 2023)</em>, pp. 70-79. AAAI Press, 2023.</p>
<pre><code>landmark_cost_partitioning(lm_factory, pref=false, prog_goal=true, prog_gn=true, prog_r=true, verbosity=normal, transform=no_transform(), cache_estimates=true, cost_partitioning=uniform, scoring_function=max_heuristic_per_stolen_costs, alm=true, lpsolver=cplex, random_seed=-1)
</code></pre>
<ul>
<li><em>lm_factory</em> (<a href="../LandmarkFactory/">LandmarkFactory</a>): the set of landmarks to use for this heuristic. The set of landmarks can be specified here, or predefined (see <a href="../LandmarkFactory/">LandmarkFactory</a>).</li>
<li><em>pref</em> (bool): enable preferred operators (see note below)</li>
<li><em>prog_goal</em> (bool): Use goal progression.</li>
<li><em>prog_gn</em> (bool): Use greedy-necessary ordering progression.</li>
<li><em>prog_r</em> (bool): Use reasonable ordering progression.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>cost_partitioning</em> ({optimal, uniform, opportunistic_uniform, greedy_zero_one, saturated, canonical, pho}): strategy for partitioning operator costs among landmarks</li>
<li><code>optimal</code>: use optimal (LP-based) cost partitioning</li>
<li><code>uniform</code>: partition operator costs uniformly among all landmarks achieved by that operator</li>
<li><code>opportunistic_uniform</code>: like uniform, but order landmarks and reuse costs not consumed by earlier landmarks</li>
<li><code>greedy_zero_one</code>: order landmarks and give each landmark the costs of all the operators it contains</li>
<li><code>saturated</code>: like greedy_zero_one, but reuse costs not consumed by earlier landmarks</li>
<li><code>canonical</code>: canonical heuristic over landmarks</li>
<li><code>pho</code>: post-hoc optimization over landmarks</li>
<li><em>scoring_function</em> ({max_heuristic, min_stolen_costs, max_heuristic_per_stolen_costs}): metric for ordering abstractions/landmarks</li>
<li><code>max_heuristic</code>: order by decreasing heuristic value for the given state</li>
<li><code>min_stolen_costs</code>: order by increasing sum of costs stolen from other heuristics</li>
<li><code>max_heuristic_per_stolen_costs</code>: order by decreasing ratio of heuristic value divided by sum of stolen costs</li>
<li><em>alm</em> (bool): use action landmarks</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p><strong>Usage with A*:</strong> We recommend to add this heuristic as lazy_evaluator when using it in the A* algorithm. This way, the heuristic is recomputed before a state is expanded, leading to improved estimates that incorporate all knowledge gained from paths that were found after the state was inserted into the open list.</p>
<p><strong>Consistency:</strong> The heuristic is consistent along single paths if it is set as lazy_evaluator; i.e. when expanding s then we have h(s) &lt;= h(s')+cost(a) for all successors s' of s reached with a. But newly found paths to s can increase h(s), at which point the above inequality might not hold anymore.</p>
<p><strong>Optimal Cost Partitioning:</strong> To use <code>cost_partitioning=optimal</code>, you must build the planner with LP support. See LPBuildInstructions.</p>
<p><strong>Preferred operators:</strong> Preferred operators should not be used for optimal planning. See <a href="./#landmark_sum_heuristic">Landmark sum heuristic</a> for more information on using preferred operators; the comments there also apply to this heuristic.</p>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional_effects:</strong> supported if the <a href="../LandmarkFactory/">LandmarkFactory</a> supports them; otherwise not supported
 * <strong>axioms:</strong> not allowed
Properties:
 * <strong>preferred operators:</strong> yes (if enabled; see <code>pref</code> option)
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> no; see document note about consistency
 * <strong>safe:</strong> yes
== Landmark sum heuristic ==
Landmark progression is implemented according to the following paper:</p>
<p>Clemens Büchner, Thomas Keller, Salomé Eriksson and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/buechner-et-al-icaps2023.pdf">Landmarks Progression in Heuristic Search</a>.<br />
In <em>Proceedings of the Thirty-Third International Conference on Automated Planning and Scheduling (ICAPS 2023)</em>, pp. 70-79. AAAI Press, 2023.</p>
<pre><code>landmark_sum(lm_factory, pref=false, prog_goal=true, prog_gn=true, prog_r=true, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>lm_factory</em> (<a href="../LandmarkFactory/">LandmarkFactory</a>): the set of landmarks to use for this heuristic. The set of landmarks can be specified here, or predefined (see <a href="../LandmarkFactory/">LandmarkFactory</a>).</li>
<li><em>pref</em> (bool): enable preferred operators (see note below)</li>
<li><em>prog_goal</em> (bool): Use goal progression.</li>
<li><em>prog_gn</em> (bool): Use greedy-necessary ordering progression.</li>
<li><em>prog_r</em> (bool): Use reasonable ordering progression.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
<strong>Note on performance for satisficing planning:</strong> The cost of a landmark is based on the cost of the operators that achieve it. For satisficing search this can be counterproductive since it is often better to focus on distance from goal (i.e. length of the plan) rather than cost. In experiments we achieved the best performance using the option 'transform=adapt_costs(one)' to enforce unit costs.</li>
</ul>
<p><strong>Preferred operators:</strong> Computing preferred operators is <em>only enabled</em> when setting pref=true because it has a nontrivial runtime cost. Using the heuristic for preferred operators without setting pref=true has no effect.
Our implementation to compute preferred operators based on landmarks differs from the description in the literature (see reference above).The original implementation computes two kinds of preferred operators:</p>
<ol>
<li>If there is an applicable operator that reaches a landmark, all such operators are preferred.</li>
<li>If no such operators exist, perform an FF-style relaxed exploration towards the nearest landmarks (according to the landmark orderings) and use the preferred operators of this exploration.</li>
</ol>
<p>Our implementation only considers preferred operators of the first type and does not include the second type. The rationale for this change is that it reduces code complexity and helps more cleanly separate landmark-based and FF-based computations in LAMA-like planner configurations. In our experiments, only considering preferred operators of the first type reduces performance when using the heuristic and its preferred operators in isolation but improves performance when using this heuristic in conjunction with the FF heuristic, as in LAMA-like planner configurations.</p>
<p>Language features supported:</p>
<ul>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional_effects:</strong> supported if the <a href="../LandmarkFactory/">LandmarkFactory</a> supports them; otherwise ignored</li>
<li><strong>axioms:</strong> ignored
Properties:</li>
<li><strong>preferred operators:</strong> yes (if enabled; see <code>pref</code> option)</li>
<li><strong>admissible:</strong> no</li>
<li><strong>consistent:</strong> no</li>
<li>
<p><strong>safe:</strong> yes except on tasks with axioms or on tasks with conditional effects when using a <a href="../LandmarkFactory/">LandmarkFactory</a> not supporting them
== Landmark-cut heuristic ==
    lmcut(verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no
== Merge-and-shrink heuristic ==
This heuristic implements the algorithm described in the following paper:</li>
</ul>
<p>Silvan Sievers, Martin Wehrle and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/sievers-et-al-aaai2014.pdf">Generalized Label Reduction for Merge-and-Shrink Heuristics</a>.<br />
In <em>Proceedings of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014)</em>, pp. 2358-2366. AAAI Press, 2014.</p>
<p>For a more exhaustive description of merge-and-shrink, see the journal paper</p>
<p>Silvan Sievers and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/sievers-helmert-jair2021.pdf">Merge-and-Shrink: A Compositional Theory of Transformations of Factored Transition Systems</a>.<br />
 <em>Journal of Artificial Intelligence Research</em> 71:781-883. 2021.</p>
<p>The following paper describes how to improve the DFP merge strategy with tie-breaking, and presents two new merge strategies (dyn-MIASM and SCC-DFP):</p>
<p>Silvan Sievers, Martin Wehrle and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/sievers-et-al-icaps2016.pdf">An Analysis of Merge Strategies for Merge-and-Shrink Heuristics</a>.<br />
 In <em>Proceedings of the 26th International Conference on Automated Planning and Scheduling (ICAPS 2016)</em>, pp. 294-298. AAAI Press, 2016.</p>
<p>Details of the algorithms and the implementation are described in the paper</p>
<p>Silvan Sievers.<br />
 <a href="https://ai.dmi.unibas.ch/papers/sievers-socs2018.pdf">Merge-and-Shrink Heuristics for Classical Planning: Efficient Implementation and Partial Abstractions</a>.<br />
 In <em>Proceedings of the 11th Annual Symposium on Combinatorial Search (SoCS 2018)</em>, pp. 90-98. AAAI Press, 2018.</p>
<pre><code>merge_and_shrink(verbosity=normal, transform=no_transform(), cache_estimates=true, merge_strategy, shrink_strategy, label_reduction=&lt;none&gt;, prune_unreachable_states=true, prune_irrelevant_states=true, max_states=-1, max_states_before_merge=-1, threshold_before_merge=-1, main_loop_max_time=infinity)
</code></pre>
<ul>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>merge_strategy</em> (<a href="../MergeStrategy/">MergeStrategy</a>): See detailed documentation for merge strategies. We currently recommend SCC-DFP, which can be achieved using <code>merge_strategy=merge_sccs(order_of_sccs=topological,merge_selector=score_based_filtering(scoring_functions=[goal_relevance,dfp,total_order]))</code></li>
<li><em>shrink_strategy</em> (<a href="../ShrinkStrategy/">ShrinkStrategy</a>): See detailed documentation for shrink strategies. We currently recommend non-greedy shrink_bisimulation, which can be achieved using <code>shrink_strategy=shrink_bisimulation(greedy=false)</code></li>
<li><em>label_reduction</em> (<a href="../LabelReduction/">LabelReduction</a>): See detailed documentation for labels. There is currently only one 'option' to use label_reduction, which is <code>label_reduction=exact</code> Also note the interaction with shrink strategies.</li>
<li><em>prune_unreachable_states</em> (bool): If true, prune abstract states unreachable from the initial state.</li>
<li><em>prune_irrelevant_states</em> (bool): If true, prune abstract states from which no goal state can be reached.</li>
<li><em>max_states</em> (int [-1, infinity]): maximum transition system size allowed at any time point.</li>
<li><em>max_states_before_merge</em> (int [-1, infinity]): maximum transition system size allowed for two transition systems before being merged to form the synchronized product.</li>
<li><em>threshold_before_merge</em> (int [-1, infinity]): If a transition system, before being merged, surpasses this soft transition system size limit, the shrink strategy is called to possibly shrink the transition system.</li>
<li><em>main_loop_max_time</em> (double [0.0, infinity]): A limit in seconds on the runtime of the main loop of the algorithm. If the limit is exceeded, the algorithm terminates, potentially returning a factored transition system with several factors. Also note that the time limit is only checked between transformations of the main loop, but not during, so it can be exceeded if a transformation is runtime-intense.
<strong>Note:</strong> Conditional effects are supported directly. Note, however, that for tasks that are not factored (in the sense of the JACM 2014 merge-and-shrink paper), the atomic transition systems on which merge-and-shrink heuristics are based are nondeterministic, which can lead to poor heuristics even when only perfect shrinking is performed.</li>
</ul>
<p><strong>Note:</strong> When pruning unreachable states, admissibility and consistency is only guaranteed for reachable states and transitions between reachable states. While this does not impact regular A* search which will never encounter any unreachable state, it impacts techniques like symmetry-based pruning: a reachable state which is mapped to an unreachable symmetric state (which hence is pruned) would falsely be considered a dead-end and also be pruned, thus violating optimality of the search.</p>
<p><strong>Note:</strong> When using a time limit on the main loop of the merge-and-shrink algorithm, the heuristic will compute the maximum over all heuristics induced by the remaining factors if terminating the merge-and-shrink algorithm early. Exception: if there is an unsolvable factor, it will be used as the exclusive heuristic since the problem is unsolvable.</p>
<p><strong>Note:</strong> A currently recommended good configuration uses bisimulation based shrinking, the merge strategy SCC-DFP, and the appropriate label reduction setting (max_states has been altered to be between 10k and 200k in the literature). As merge-and-shrink heuristics can be expensive to compute, we also recommend limiting time by setting <code>main_loop_max_time</code> to a finite value. A sensible value would be half of the time allocated for the planner.</p>
<pre><code>merge_and_shrink(shrink_strategy=shrink_bisimulation(greedy=false),merge_strategy=merge_sccs(order_of_sccs=topological,merge_selector=score_based_filtering(scoring_functions=[goal_relevance,dfp,total_order])),label_reduction=exact(before_shrinking=true,before_merging=false),max_states=50k,threshold_before_merge=1)
</code></pre>
<p>Language features supported:</p>
<ul>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> supported (but see note)</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes (but see note)</li>
<li><strong>consistent:</strong> yes (but see note)</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no
== Operator-counting heuristic ==
An operator-counting heuristic computes a linear program (LP) in each state. The LP has one variable Count_o for each operator o that represents how often the operator is used in a plan. Operator-counting constraints are linear constraints over these varaibles that are guaranteed to have a solution with Count_o = occurrences(o, pi) for every plan pi. Minimizing the total cost of operators subject to some operator-counting constraints is an admissible heuristic. For details, see</li>
</ul>
<p>Florian Pommerening, Gabriele Roeger, Malte Helmert and Blai Bonet.<br />
<a href="http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031">LP-based Heuristics for Cost-optimal Planning</a>.<br />
In <em>Proceedings of the Twenty-Fourth International Conference on Automated Planning and Scheduling (ICAPS 2014)</em>, pp. 226-234. AAAI Press, 2014.</p>
<pre><code>operatorcounting(constraint_generators, use_integer_operator_counts=false, lpsolver=cplex, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>constraint_generators</em> (list of <a href="../ConstraintGenerator/">ConstraintGenerator</a>): methods that generate constraints over operator-counting variables</li>
<li><em>use_integer_operator_counts</em> (bool): restrict operator-counting variables to integer values. Computing the heuristic with integer variables can produce higher values but requires solving a MIP instead of an LP which is generally more computationally expensive. Turning this option on can thus drastically increase the runtime.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented constraint generators do)
 * <strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented constraint generators do)
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes, if all constraint generators represent consistent heuristics
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no</p>
<p>= Basic Evaluators =</p>
<p>== Constant evaluator ==
Returns a constant value.
    const(value=1, verbosity=normal)</p>
<ul>
<li><em>value</em> (int [0, infinity]): the constant value</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li>
<p><code>debug</code>: like verbose with additional debug output
== g-value evaluator ==
Returns the g-value (path cost) of the search node.
    g(verbosity=normal)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li>
<p><code>debug</code>: like verbose with additional debug output
== Max evaluator ==
Calculates the maximum of the sub-evaluators.
    max(evals, verbosity=normal)</p>
</li>
<li>
<p><em>evals</em> (list of <a href="./">Evaluator</a>): at least one evaluator</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li>
<p><code>debug</code>: like verbose with additional debug output
== Preference evaluator ==
Returns 0 if preferred is true and 1 otherwise.
    pref(verbosity=normal)</p>
</li>
<li>
<p><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</p>
</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li>
<p><code>debug</code>: like verbose with additional debug output
== Sum evaluator ==
Calculates the sum of the sub-evaluators.
    sum(evals, verbosity=normal)</p>
</li>
<li>
<p><em>evals</em> (list of <a href="./">Evaluator</a>): at least one evaluator</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li>
<p><code>debug</code>: like verbose with additional debug output
== Weighted evaluator ==
Multiplies the value of the evaluator with the given weight.
    weight(eval, weight, verbosity=normal)</p>
</li>
<li>
<p><em>eval</em> (<a href="./">Evaluator</a>): evaluator</p>
</li>
<li><em>weight</em> (int): weight</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
</ul>
<p>= Cost Partitioning Heuristics =</p>
<p>== Canonical heuristic over abstractions ==
Shuffle abstractions randomly.
    canonical_heuristic(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
<ul>
<li><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)</li>
<li><strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Greedy zero-one cost partitioning ==
    gzocp(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, orders=greedy_orders(), max_orders=infinity, max_size=infinity, max_time=200, diversify=true, samples=1000, max_optimization_time=2, random_seed=-1)</p>
</li>
<li>
<p><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>orders</em> (<a href="../OrderGenerator/">OrderGenerator</a>): order generator</li>
<li><em>max_orders</em> (int [0, infinity]): maximum number of orders</li>
<li><em>max_size</em> (int [0, infinity]): maximum heuristic size in KiB</li>
<li><em>max_time</em> (double [0, infinity]): maximum time in seconds for finding orders</li>
<li><em>diversify</em> (bool): only keep orders that have a higher heuristic value than all previous orders for any of the samples</li>
<li><em>samples</em> (int [1, infinity]): number of samples for diversification</li>
<li><em>max_optimization_time</em> (double [0, infinity]): maximum time in seconds for optimizing each order with hill climbing</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)</li>
<li><strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Maximum over abstractions ==
Maximize over a set of abstraction heuristics.
    maximize(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)</li>
<li><strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Optimal cost partitioning heuristic ==
Compute an optimal cost partitioning for each evaluated state.
    ocp(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, lpsolver=cplex, allow_negative_costs=true)</p>
</li>
<li>
<p><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>allow_negative_costs</em> (bool): use general instead of non-negative cost partitioning
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
 * <strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Post-hoc optimization heuristic ==
Compute the maximum over multiple PhO heuristics precomputed offline.
    pho(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, saturated=true, orders=greedy_orders(), max_orders=infinity, max_size=infinity, max_time=200, diversify=true, samples=1000, max_optimization_time=2, random_seed=-1, lpsolver=cplex)</p>
<ul>
<li><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>saturated</em> (bool): saturate costs</li>
<li><em>orders</em> (<a href="../OrderGenerator/">OrderGenerator</a>): order generator</li>
<li><em>max_orders</em> (int [0, infinity]): maximum number of orders</li>
<li><em>max_size</em> (int [0, infinity]): maximum heuristic size in KiB</li>
<li><em>max_time</em> (double [0, infinity]): maximum time in seconds for finding orders</li>
<li><em>diversify</em> (bool): only keep orders that have a higher heuristic value than all previous orders for any of the samples</li>
<li><em>samples</em> (int [1, infinity]): number of samples for diversification</li>
<li><em>max_optimization_time</em> (double [0, infinity]): maximum time in seconds for optimizing each order with hill climbing</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
 * <strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Saturated cost partitioning ==
Compute the maximum over multiple saturated cost partitioning heuristics using different orders. For details, see </p>
<p>Jendrik Seipp, Thomas Keller and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-jair2020.pdf">Saturated Cost Partitioning for Optimal Classical Planning</a>.<br />
<em>Journal of Artificial Intelligence Research</em> 67:129-167. 2020.</p>
<pre><code>scp(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, saturator=all, orders=greedy_orders(), max_orders=infinity, max_size=infinity, max_time=200, diversify=true, samples=1000, max_optimization_time=2, random_seed=-1)
</code></pre>
<ul>
<li><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>saturator</em> ({all, perim, perimstar}): function that computes saturated cost functions</li>
<li><code>all</code>: preserve estimates of all states</li>
<li><code>perim</code>: preserve estimates of states in perimeter around goal</li>
<li><code>perimstar</code>: compute 'perim' first and then 'all' with remaining costs</li>
<li><em>orders</em> (<a href="../OrderGenerator/">OrderGenerator</a>): order generator</li>
<li><em>max_orders</em> (int [0, infinity]): maximum number of orders</li>
<li><em>max_size</em> (int [0, infinity]): maximum heuristic size in KiB</li>
<li><em>max_time</em> (double [0, infinity]): maximum time in seconds for finding orders</li>
<li><em>diversify</em> (bool): only keep orders that have a higher heuristic value than all previous orders for any of the samples</li>
<li><em>samples</em> (int [1, infinity]): number of samples for diversification</li>
<li><em>max_optimization_time</em> (double [0, infinity]): maximum time in seconds for optimizing each order with hill climbing</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
<strong>Difference to cegar():</strong> The cegar() plugin computes a single saturated cost partitioning over Cartesian abstraction heuristics. In contrast, saturated_cost_partitioning() supports computing the maximum over multiple saturated cost partitionings using different heuristic orders, and it supports both Cartesian abstraction heuristics and pattern database heuristics. While cegar() interleaves abstraction computation with cost partitioning, saturated_cost_partitioning() computes all abstractions using the original costs.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
 * <strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Online saturated cost partitioning ==
Compute the maximum over multiple saturated cost partitioning heuristics diversified during the search. For details, see </p>
<p>Jendrik Seipp.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-icaps2021.pdf">Online Saturated Cost Partitioning for Classical Planning</a>.<br />
In <em>Proceedings of the 31st International Conference on Automated Planning and Scheduling (ICAPS 2021)</em>, pp. 317-321. AAAI Press, 2021.</p>
<pre><code>scp_online(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, saturator=all, orders=greedy_orders(), max_size=infinity, max_time=200, interval=10K, debug=false, random_seed=-1)
</code></pre>
<ul>
<li><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>saturator</em> ({all, perim, perimstar}): function that computes saturated cost functions</li>
<li><code>all</code>: preserve estimates of all states</li>
<li><code>perim</code>: preserve estimates of states in perimeter around goal</li>
<li><code>perimstar</code>: compute 'perim' first and then 'all' with remaining costs</li>
<li><em>orders</em> (<a href="../OrderGenerator/">OrderGenerator</a>): order generator</li>
<li><em>max_size</em> (int [0, infinity]): maximum (estimated) heuristic size in KiB</li>
<li><em>max_time</em> (double [0, infinity]): maximum time in seconds for finding orders</li>
<li><em>interval</em> (int [1, infinity]): select every i-th evaluated state for online diversification</li>
<li><em>debug</em> (bool): print debug output</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)</li>
<li><strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> no</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no
== (Opportunistic) uniform cost partitioning ==</li>
</ul>
<p>Jendrik Seipp, Thomas Keller and Malte Helmert.<br />
 <a href="https://jendrikseipp.com/papers/seipp-et-al-icaps2017.pdf">A Comparison of Cost Partitioning Algorithms for Optimal Classical Planning</a>.<br />
 In <em>Proceedings of the Twenty-Seventh International Conference on Automated Planning and Scheduling (ICAPS 2017)</em>, pp. 259-268. AAAI Press, 2017.</p>
<pre><code>ucp(abstractions=[projections(hillclimbing(max_time=60)), projections(systematic(2)), cartesian()], verbosity=normal, transform=no_transform(), cache_estimates=true, orders=greedy_orders(), max_orders=infinity, max_size=infinity, max_time=200, diversify=true, samples=1000, max_optimization_time=2, random_seed=-1, opportunistic=false, debug=false)
</code></pre>
<ul>
<li><em>abstractions</em> (list of <a href="../AbstractionGenerator/">AbstractionGenerator</a>): abstraction generators</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>orders</em> (<a href="../OrderGenerator/">OrderGenerator</a>): order generator</li>
<li><em>max_orders</em> (int [0, infinity]): maximum number of orders</li>
<li><em>max_size</em> (int [0, infinity]): maximum heuristic size in KiB</li>
<li><em>max_time</em> (double [0, infinity]): maximum time in seconds for finding orders</li>
<li><em>diversify</em> (bool): only keep orders that have a higher heuristic value than all previous orders for any of the samples</li>
<li><em>samples</em> (int [1, infinity]): number of samples for diversification</li>
<li><em>max_optimization_time</em> (double [0, infinity]): maximum time in seconds for optimizing each order with hill climbing</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>opportunistic</em> (bool): recalculate uniform cost partitioning after each considered abstraction</li>
<li><em>debug</em> (bool): print debugging messages
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)</li>
<li><strong>axioms:</strong> not supported (the heuristic supports them in theory, but none of the currently implemented abstraction generators do)
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no</li>
</ul>
<p>= Pattern Database Heuristics =</p>
<p>== Canonical PDB ==
The canonical pattern database heuristic is calculated as follows. For a given pattern collection C, the value of the canonical heuristic function is the maximum over all maximal additive subsets A in C, where the value for one subset S in A is the sum of the heuristic values for all patterns in S for a given state.
    cpdbs(patterns=systematic(1), max_time_dominance_pruning=infinity, verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
<ul>
<li><em>patterns</em> (<a href="../PatternCollectionGenerator/">PatternCollectionGenerator</a>): pattern generation method</li>
<li><em>max_time_dominance_pruning</em> (double [0.0, infinity]): The maximum time in seconds spent on dominance pruning. Using 0.0 turns off dominance pruning. Dominance pruning excludes patterns and additive subsets that will never contribute to the heuristic value because there are dominating subsets in the collection.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no
== iPDB ==
This approach is a combination of using the <a href="./#canonical_pdb">Canonical PDB</a> heuristic over patterns computed with the <a href="../PatternCollectionGenerator/#hillclimbing">hillclimbing</a> algorithm for pattern generation. It is a short-hand for the command-line option <code>cpdbs(hillclimbing())</code>. Both the heuristic and the pattern generation algorithm are described in the following paper:</li>
</ul>
<p>Patrik Haslum, Adi Botea, Malte Helmert, Blai Bonet and Sven Koenig.<br />
<a href="http://www.informatik.uni-freiburg.de/~ki/papers/haslum-etal-aaai07.pdf">Domain-Independent Construction of Pattern Database Heuristics for Cost-Optimal Planning</a>.<br />
In <em>Proceedings of the 22nd AAAI Conference on Artificial Intelligence (AAAI 2007)</em>, pp. 1007-1012. AAAI Press, 2007.</p>
<p>For implementation notes, see:</p>
<p>Silvan Sievers, Manuela Ortlieb and Malte Helmert.<br />
 <a href="https://ai.dmi.unibas.ch/papers/sievers-et-al-socs2012.pdf">Efficient Implementation of Pattern Database Heuristics for Classical Planning</a>.<br />
 In <em>Proceedings of the Fifth Annual Symposium on Combinatorial Search (SoCS 2012)</em>, pp. 105-111. AAAI Press, 2012.</p>
<p>See also <a href="./#canonical_pdb">Canonical PDB</a> and <a href="../PatternCollectionGenerator/#hill_climbing">Hill climbing</a> for more details.</p>
<pre><code>ipdb(pdb_max_size=2000000, collection_max_size=20000000, num_samples=1000, min_improvement=10, max_time=infinity, max_generated_patterns=infinity, random_seed=-1, max_time_dominance_pruning=infinity, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>pdb_max_size</em> (int [1, infinity]): maximal number of states per pattern database </li>
<li><em>collection_max_size</em> (int [1, infinity]): maximal number of states in the pattern collection</li>
<li><em>num_samples</em> (int [1, infinity]): number of samples (random states) on which to evaluate each candidate pattern collection</li>
<li><em>min_improvement</em> (int [1, infinity]): minimum number of samples on which a candidate pattern collection must improve on the current one to be considered as the next pattern collection </li>
<li><em>max_time</em> (double [0.0, infinity]): maximum time in seconds for improving the initial pattern collection via hill climbing. If set to 0, no hill climbing is performed at all. Note that this limit only affects hill climbing. Use max_time_dominance_pruning to limit the time spent for pruning dominated patterns.</li>
<li><em>max_generated_patterns</em> (int [0, infinity]): maximum number of generated patterns</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>max_time_dominance_pruning</em> (double [0.0, infinity]): The maximum time in seconds spent on dominance pruning. Using 0.0 turns off dominance pruning. Dominance pruning excludes patterns and additive subsets that will never contribute to the heuristic value because there are dominating subsets in the collection.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
<strong>Note:</strong> The pattern collection created by the algorithm will always contain all patterns consisting of a single goal variable, even if this violates the pdb_max_size or collection_max_size limits.</li>
</ul>
<p><strong>Note:</strong> This pattern generation method generates patterns optimized for use with the canonical pattern database heuristic.</p>
<p>=== Implementation Notes ===
The following will very briefly describe the algorithm and explain the differences between the original implementation from 2007 and the new one in Fast Downward.</p>
<p>The aim of the algorithm is to output a pattern collection for which the <a href="./#canonical_pdb">Canonical PDB</a> yields the best heuristic estimates.</p>
<p>The algorithm is basically a local search (hill climbing) which searches the "pattern neighbourhood" (starting initially with a pattern for each goal variable) for improving the pattern collection. This is done as described in the section "pattern construction as search" in the paper, except for the corrected search neighbourhood discussed below. For evaluating the neighbourhood, the "counting approximation" as introduced in the paper was implemented. An important difference however consists in the fact that this implementation computes all pattern databases for each candidate pattern rather than using A* search to compute the heuristic values only for the sample states for each pattern.</p>
<p>Also the logic for sampling the search space differs a bit from the original implementation. The original implementation uses a random walk of a length which is binomially distributed with the mean at the estimated solution depth (estimation is done with the current pattern collection heuristic). In the Fast Downward implementation, also a random walk is used, where the length is the estimation of the number of solution steps, which is calculated by dividing the current heuristic estimate for the initial state by the average operator costs of the planning task (calculated only once and not updated during sampling!) to take non-unit cost problems into account. This yields a random walk of an expected lenght of np = 2 * estimated number of solution steps. If the random walk gets stuck, it is being restarted from the initial state, exactly as described in the original paper.</p>
<p>The section "avoiding redundant evaluations" describes how the search neighbourhood of patterns can be restricted to variables that are relevant to the variables already included in the pattern by analyzing causal graphs. There is a mistake in the paper that leads to some relevant neighbouring patterns being ignored. See the <a href="https://ai.dmi.unibas.ch/research/publications.html">errata</a> for details. This mistake has been addressed in this implementation. The second approach described in the paper (statistical confidence interval) is not applicable to this implementation, as it doesn't use A* search but constructs the entire pattern databases for all candidate patterns anyway.
The search is ended if there is no more improvement (or the improvement is smaller than the minimal improvement which can be set as an option), however there is no limit of iterations of the local search. This is similar to the techniques used in the original implementation as described in the paper.</p>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported
 * <strong>axioms:</strong> not supported
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Pattern database heuristic ==
TODO
    pdb(pattern=greedy(), verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
<ul>
<li><em>pattern</em> (<a href="../PatternGenerator/">PatternGenerator</a>): pattern generation method</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li>
<p><strong>preferred operators:</strong> no
== Zero-One PDB ==
The zero/one pattern database heuristic is simply the sum of the heuristic values of all patterns in the pattern collection. In contrast to the canonical pattern database heuristic, there is no need to check for additive subsets, because the additivity of the patterns is guaranteed by action cost partitioning. This heuristic uses the most simple form of action cost partitioning, i.e. if an operator affects more than one pattern in the collection, its costs are entirely taken into account for one pattern (the first one which it affects) and set to zero for all other affected patterns.
    zopdbs(patterns=systematic(1), verbosity=normal, transform=no_transform(), cache_estimates=true)</p>
</li>
<li>
<p><em>patterns</em> (<a href="../PatternCollectionGenerator/">PatternCollectionGenerator</a>): pattern generation method</p>
</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
Language features supported:</li>
<li><strong>action costs:</strong> supported</li>
<li><strong>conditional effects:</strong> not supported</li>
<li><strong>axioms:</strong> not supported
Properties:</li>
<li><strong>admissible:</strong> yes</li>
<li><strong>consistent:</strong> yes</li>
<li><strong>safe:</strong> yes</li>
<li><strong>preferred operators:</strong> no</li>
</ul>
<p>= Potential Heuristics =</p>
<p>== Potential heuristic optimized for all states ==
The algorithm is based on</p>
<p>Jendrik Seipp, Florian Pommerening and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-icaps2015.pdf">New Optimization Functions for Potential Heuristics</a>.<br />
In <em>Proceedings of the 25th International Conference on Automated Planning and Scheduling (ICAPS 2015)</em>, pp. 193-201. AAAI Press, 2015.</p>
<pre><code>all_states_potential(max_potential=1e8, lpsolver=cplex, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>max_potential</em> (double [0.0, infinity]): Bound potentials by this number. Using the bound <code>infinity</code> disables the bounds. In some domains this makes the computation of weights unbounded in which case no weights can be extracted. Using very high weights can cause numerical instability in the LP solver, while using very low weights limits the choice of potential heuristics. For details, see the ICAPS paper cited above.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported
 * <strong>axioms:</strong> not supported
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Diverse potential heuristics ==
The algorithm is based on</p>
<p>Jendrik Seipp, Florian Pommerening and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-icaps2015.pdf">New Optimization Functions for Potential Heuristics</a>.<br />
In <em>Proceedings of the 25th International Conference on Automated Planning and Scheduling (ICAPS 2015)</em>, pp. 193-201. AAAI Press, 2015.</p>
<pre><code>diverse_potentials(num_samples=1000, max_num_heuristics=infinity, max_potential=1e8, lpsolver=cplex, verbosity=normal, transform=no_transform(), cache_estimates=true, random_seed=-1)
</code></pre>
<ul>
<li><em>num_samples</em> (int [0, infinity]): Number of states to sample</li>
<li><em>max_num_heuristics</em> (int [0, infinity]): maximum number of potential heuristics</li>
<li><em>max_potential</em> (double [0.0, infinity]): Bound potentials by this number. Using the bound <code>infinity</code> disables the bounds. In some domains this makes the computation of weights unbounded in which case no weights can be extracted. Using very high weights can cause numerical instability in the LP solver, while using very low weights limits the choice of potential heuristics. For details, see the ICAPS paper cited above.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported
 * <strong>axioms:</strong> not supported
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Potential heuristic optimized for initial state ==
The algorithm is based on</p>
<p>Jendrik Seipp, Florian Pommerening and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-icaps2015.pdf">New Optimization Functions for Potential Heuristics</a>.<br />
In <em>Proceedings of the 25th International Conference on Automated Planning and Scheduling (ICAPS 2015)</em>, pp. 193-201. AAAI Press, 2015.</p>
<pre><code>initial_state_potential(max_potential=1e8, lpsolver=cplex, verbosity=normal, transform=no_transform(), cache_estimates=true)
</code></pre>
<ul>
<li><em>max_potential</em> (double [0.0, infinity]): Bound potentials by this number. Using the bound <code>infinity</code> disables the bounds. In some domains this makes the computation of weights unbounded in which case no weights can be extracted. Using very high weights can cause numerical instability in the LP solver, while using very low weights limits the choice of potential heuristics. For details, see the ICAPS paper cited above.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported
 * <strong>axioms:</strong> not supported
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no
== Sample-based potential heuristics ==
Maximum over multiple potential heuristics optimized for samples. The algorithm is based on</p>
<p>Jendrik Seipp, Florian Pommerening and Malte Helmert.<br />
<a href="https://ai.dmi.unibas.ch/papers/seipp-et-al-icaps2015.pdf">New Optimization Functions for Potential Heuristics</a>.<br />
In <em>Proceedings of the 25th International Conference on Automated Planning and Scheduling (ICAPS 2015)</em>, pp. 193-201. AAAI Press, 2015.</p>
<pre><code>sample_based_potentials(num_heuristics=1, num_samples=1000, max_potential=1e8, lpsolver=cplex, verbosity=normal, transform=no_transform(), cache_estimates=true, random_seed=-1)
</code></pre>
<ul>
<li><em>num_heuristics</em> (int [0, infinity]): number of potential heuristics</li>
<li><em>num_samples</em> (int [0, infinity]): Number of states to sample</li>
<li><em>max_potential</em> (double [0.0, infinity]): Bound potentials by this number. Using the bound <code>infinity</code> disables the bounds. In some domains this makes the computation of weights unbounded in which case no weights can be extracted. Using very high weights can cause numerical instability in the LP solver, while using very low weights limits the choice of potential heuristics. For details, see the ICAPS paper cited above.</li>
<li><em>lpsolver</em> ({cplex, soplex}): external solver that should be used to solve linear programs</li>
<li><code>cplex</code>: commercial solver by IBM</li>
<li><code>soplex</code>: open source solver by ZIB</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.</li>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like verbose with additional debug output</li>
<li><em>transform</em> (<a href="../AbstractTask/">AbstractTask</a>): Optional task transformation for the heuristic. Currently, adapt_costs() and no_transform() are available.</li>
<li><em>cache_estimates</em> (bool): cache heuristic estimates</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.
<strong>Note:</strong> to use an LP solver, you must build the planner with LP support. See LPBuildInstructions.</li>
</ul>
<p>Language features supported:
 * <strong>action costs:</strong> supported
 * <strong>conditional effects:</strong> not supported
 * <strong>axioms:</strong> not supported
Properties:
 * <strong>admissible:</strong> yes
 * <strong>consistent:</strong> yes
 * <strong>safe:</strong> yes
 * <strong>preferred operators:</strong> no</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../ConstraintGenerator/" class="md-footer__link md-footer__link--prev" aria-label="Previous: ConstraintGenerator" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              ConstraintGenerator
            </div>
          </div>
        </a>
      
      
        
        <a href="../LabelReduction/" class="md-footer__link md-footer__link--next" aria-label="Next: LabelReduction" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              LabelReduction
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.f8263e09.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.4fc53ad4.min.js"></script>
      
    
  </body>
</html>