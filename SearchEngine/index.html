
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.3.0">
    
    
      
        <title>SearchEngine - Plugins</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8b42a75e.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a_search_eager" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Plugins" class="md-header__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Plugins
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SearchEngine
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Plugins" class="md-nav__button md-logo" aria-label="Plugins" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Plugins
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../AbstractTask/" class="md-nav__link">
        AbstractTask
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../AbstractionGenerator/" class="md-nav__link">
        AbstractionGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ConstraintGenerator/" class="md-nav__link">
        ConstraintGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Evaluator/" class="md-nav__link">
        Evaluator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../LabelReduction/" class="md-nav__link">
        LabelReduction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../LandmarkFactory/" class="md-nav__link">
        LandmarkFactory
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeScoringFunction/" class="md-nav__link">
        MergeScoringFunction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeSelector/" class="md-nav__link">
        MergeSelector
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeStrategy/" class="md-nav__link">
        MergeStrategy
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MergeTree/" class="md-nav__link">
        MergeTree
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../OpenList/" class="md-nav__link">
        OpenList
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../OrderGenerator/" class="md-nav__link">
        OrderGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PatternCollectionGenerator/" class="md-nav__link">
        PatternCollectionGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PatternGenerator/" class="md-nav__link">
        PatternGenerator
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PruningMethod/" class="md-nav__link">
        PruningMethod
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          SearchEngine
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        SearchEngine
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a_search_eager" class="md-nav__link">
    A* search (eager)
  </a>
  
    <nav class="md-nav" aria-label="A* search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_best-first_search" class="md-nav__link">
    Eager best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_eager" class="md-nav__link">
    Greedy search (eager)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search_1" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_weighted_a_search" class="md-nav__link">
    Eager weighted A* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_enforced_hill-climbing" class="md-nav__link">
    Lazy enforced hill-climbing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_search" class="md-nav__link">
    Iterated search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_best-first_search" class="md-nav__link">
    Lazy best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_lazy" class="md-nav__link">
    Greedy search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted_a_search_lazy" class="md-nav__link">
    (Weighted) A* search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="(Weighted) A* search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search_1" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ShrinkStrategy/" class="md-nav__link">
        ShrinkStrategy
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../SubtaskGenerator/" class="md-nav__link">
        SubtaskGenerator
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a_search_eager" class="md-nav__link">
    A* search (eager)
  </a>
  
    <nav class="md-nav" aria-label="A* search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_best-first_search" class="md-nav__link">
    Eager best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_eager" class="md-nav__link">
    Greedy search (eager)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (eager)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_eager_search_1" class="md-nav__link">
    Equivalent statements using general eager search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eager_weighted_a_search" class="md-nav__link">
    Eager weighted A* search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_enforced_hill-climbing" class="md-nav__link">
    Lazy enforced hill-climbing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#iterated_search" class="md-nav__link">
    Iterated search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lazy_best-first_search" class="md-nav__link">
    Lazy best-first search
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#greedy_search_lazy" class="md-nav__link">
    Greedy search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="Greedy search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#weighted_a_search_lazy" class="md-nav__link">
    (Weighted) A* search (lazy)
  </a>
  
    <nav class="md-nav" aria-label="(Weighted) A* search (lazy)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalent_statements_using_general_lazy_search_1" class="md-nav__link">
    Equivalent statements using general lazy search
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>SearchEngine</h1>
                
                <h2 id="a_search_eager">A* search (eager)<a class="headerlink" href="#a_search_eager" title="Permanent link">#</a></h2>
<p>A* is a special case of eager best first search that uses g+h as f-function. We break ties using the evaluator. Closed nodes are re-opened.</p>
<pre><code>astar(eval, lazy_evaluator=&lt;none&gt;, pruning=null(), cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>eval</em> (<a href="../Evaluator/">Evaluator</a>): evaluator for h-value</li>
<li><em>lazy_evaluator</em> (<a href="../Evaluator/">Evaluator</a>): An evaluator that re-evaluates a state before it is expanded.</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>lazy_evaluator:</strong> When a state s is taken out of the open list, the lazy evaluator h re-evaluates s. If h(s) changes (for example because h is path-dependent), s is not expanded, but instead reinserted into the open list. This option is currently only present for the A* algorithm.</p>
<h3 id="equivalent_statements_using_general_eager_search">Equivalent statements using general eager search<a class="headerlink" href="#equivalent_statements_using_general_eager_search" title="Permanent link">#</a></h3>
<pre><code>--search astar(evaluator)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h=evaluator
--search eager(tiebreaking([sum([g(), h]), h], unsafe_pruning=false),
               reopen_closed=true, f_eval=sum([g(), h]))
</code></pre>
<h2 id="eager_best-first_search">Eager best-first search<a class="headerlink" href="#eager_best-first_search" title="Permanent link">#</a></h2>
<pre><code>eager(open, reopen_closed=false, f_eval=&lt;none&gt;, preferred=[], pruning=null(), cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>open</em> (<a href="../OpenList/">OpenList</a>): open list</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>f_eval</em> (<a href="../Evaluator/">Evaluator</a>): set evaluator for jump statistics. (Optional; if no evaluator is used, jump statistics will not be displayed.)</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<h2 id="greedy_search_eager">Greedy search (eager)<a class="headerlink" href="#greedy_search_eager" title="Permanent link">#</a></h2>
<pre><code>eager_greedy(evals, preferred=[], boost=0, pruning=null(), cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Open list:</strong> In most cases, eager greedy best first search uses an alternation open list with one queue for each evaluator. If preferred operator evaluators are used, it adds an extra queue for each of these evaluators that includes only the nodes that are generated with a preferred operator. If only one evaluator and no preferred operator evaluator is used, the search does not use an alternation open list but a standard open list with only one queue.</p>
<p><strong>Closed nodes:</strong> Closed node are not re-opened</p>
<h3 id="equivalent_statements_using_general_eager_search_1">Equivalent statements using general eager search<a class="headerlink" href="#equivalent_statements_using_general_eager_search_1" title="Permanent link">#</a></h3>
<pre><code>--evaluator h2=eval2
--search eager_greedy([eval1, h2], preferred=h2, boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search eager(alt([single(h1), single(h1, pref_only=true), single(h2), 
                    single(h2, pref_only=true)], boost=100),
               preferred=h2)
</code></pre>
<hr />
<pre><code>--search eager_greedy([eval1, eval2])
</code></pre>
<p>is equivalent to</p>
<pre><code>--search eager(alt([single(eval1), single(eval2)]))
</code></pre>
<hr />
<pre><code>--evaluator h1=eval1
--search eager_greedy(h1, preferred=h1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1
--search eager(alt([single(h1), single(h1, pref_only=true)]),
               preferred=h1)
</code></pre>
<hr />
<pre><code>--search eager_greedy(eval1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search eager(single(eval1))
</code></pre>
<h2 id="eager_weighted_a_search">Eager weighted A* search<a class="headerlink" href="#eager_weighted_a_search" title="Permanent link">#</a></h2>
<pre><code>eager_wastar(evals, preferred=[], reopen_closed=true, boost=0, w=1, pruning=null(), cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>w</em> (int): evaluator weight</li>
<li><em>pruning</em> (<a href="../PruningMethod/">PruningMethod</a>): Pruning methods can prune or reorder the set of applicable operators in each state and thereby influence the number and order of successor states that are considered.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Open lists and equivalent statements using general eager search:</strong> See corresponding notes for "(Weighted) A* search (lazy)"</p>
<p><strong>Note:</strong> Eager weighted A<em> search uses an alternation open list while A</em> search uses a tie-breaking open list. Consequently, </p>
<pre><code>--search eager_wastar([h()], w=1)
</code></pre>
<p>is <strong>not</strong> equivalent to</p>
<pre><code>--search astar(h())
</code></pre>
<h2 id="lazy_enforced_hill-climbing">Lazy enforced hill-climbing<a class="headerlink" href="#lazy_enforced_hill-climbing" title="Permanent link">#</a></h2>
<pre><code>ehc(h, preferred_usage=PRUNE_BY_PREFERRED, preferred=[], cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>h</em> (<a href="../Evaluator/">Evaluator</a>): heuristic</li>
<li><em>preferred_usage</em> ({PRUNE_BY_PREFERRED, RANK_PREFERRED_FIRST}): preferred operator usage</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<h2 id="iterated_search">Iterated search<a class="headerlink" href="#iterated_search" title="Permanent link">#</a></h2>
<pre><code>iterated(engine_configs, pass_bound=true, repeat_last=false, continue_on_fail=false, continue_on_solve=true, cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>engine_configs</em> (list of ParseTree (this just means the input is parsed at a later point. The real type is probably a search engine.)): list of search engines for each phase</li>
<li><em>pass_bound</em> (bool): use bound from previous search. The bound is the real cost of the plan found before, regardless of the cost_type parameter.</li>
<li><em>repeat_last</em> (bool): repeat last phase of search</li>
<li><em>continue_on_fail</em> (bool): continue search after no solution found</li>
<li><em>continue_on_solve</em> (bool): continue search after solution found</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Note 1:</strong> We don't cache heuristic values between search iterations at the moment. If you perform a LAMA-style iterative search, heuristic values will be computed multiple times.</p>
<p><strong>Note 2:</strong> The configuration</p>
<pre><code>--search "iterated([lazy_wastar(merge_and_shrink(),w=10), lazy_wastar(merge_and_shrink(),w=5), lazy_wastar(merge_and_shrink(),w=3), lazy_wastar(merge_and_shrink(),w=2), lazy_wastar(merge_and_shrink(),w=1)])"
</code></pre>
<p>would perform the preprocessing phase of the merge and shrink heuristic 5 times (once before each iteration).</p>
<p>To avoid this, use heuristic predefinition, which avoids duplicate preprocessing, as follows:</p>
<pre><code>--evaluator "h=merge_and_shrink()" --search "iterated([lazy_wastar(h,w=10), lazy_wastar(h,w=5), lazy_wastar(h,w=3), lazy_wastar(h,w=2), lazy_wastar(h,w=1)])"
</code></pre>
<p><strong>Note 3:</strong> If you reuse the same landmark count heuristic (using heuristic predefinition) between iterations, the path data (that is, landmark status for each visited state) will be saved between iterations.</p>
<h2 id="lazy_best-first_search">Lazy best-first search<a class="headerlink" href="#lazy_best-first_search" title="Permanent link">#</a></h2>
<pre><code>lazy(open, reopen_closed=false, preferred=[], randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>open</em> (<a href="../OpenList/">OpenList</a>): open list</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
<h2 id="greedy_search_lazy">Greedy search (lazy)<a class="headerlink" href="#greedy_search_lazy" title="Permanent link">#</a></h2>
<pre><code>lazy_greedy(evals, preferred=[], reopen_closed=false, boost=1000, randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for alternation queues that are restricted to preferred operator nodes</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Open lists:</strong> In most cases, lazy greedy best first search uses an alternation open list with one queue for each evaluator. If preferred operator evaluators are used, it adds an extra queue for each of these evaluators that includes only the nodes that are generated with a preferred operator. If only one evaluator and no preferred operator evaluator is used, the search does not use an alternation open list but a standard open list with only one queue.</p>
<h3 id="equivalent_statements_using_general_lazy_search">Equivalent statements using general lazy search<a class="headerlink" href="#equivalent_statements_using_general_lazy_search" title="Permanent link">#</a></h3>
<pre><code>--evaluator h2=eval2
--search lazy_greedy([eval1, h2], preferred=h2, boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search lazy(alt([single(h1), single(h1, pref_only=true), single(h2),
                  single(h2, pref_only=true)], boost=100),
              preferred=h2)
</code></pre>
<hr />
<pre><code>--search lazy_greedy([eval1, eval2], boost=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(eval1), single(eval2)], boost=100))
</code></pre>
<hr />
<pre><code>--evaluator h1=eval1
--search lazy_greedy(h1, preferred=h1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1
--search lazy(alt([single(h1), single(h1, pref_only=true)], boost=1000),
              preferred=h1)
</code></pre>
<hr />
<pre><code>--search lazy_greedy(eval1)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(single(eval1))
</code></pre>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
<h2 id="weighted_a_search_lazy">(Weighted) A* search (lazy)<a class="headerlink" href="#weighted_a_search_lazy" title="Permanent link">#</a></h2>
<p>Weighted A* is a special case of lazy best first search.</p>
<pre><code>lazy_wastar(evals, preferred=[], reopen_closed=true, boost=1000, w=1, randomize_successors=false, preferred_successors_first=false, random_seed=-1, cost_type=NORMAL, bound=infinity, max_time=infinity, verbosity=normal)
</code></pre>
<ul>
<li><em>evals</em> (list of <a href="../Evaluator/">Evaluator</a>): evaluators</li>
<li><em>preferred</em> (list of <a href="../Evaluator/">Evaluator</a>): use preferred operators of these evaluators</li>
<li><em>reopen_closed</em> (bool): reopen closed nodes</li>
<li><em>boost</em> (int): boost value for preferred operator open lists</li>
<li><em>w</em> (int): evaluator weight</li>
<li><em>randomize_successors</em> (bool): randomize the order in which successors are generated</li>
<li><em>preferred_successors_first</em> (bool): consider preferred operators first</li>
<li><em>random_seed</em> (int [-1, infinity]): Set to -1 (default) to use the global random number generator. Set to any other value to use a local random number generator with the given seed.</li>
<li><em>cost_type</em> ({NORMAL, ONE, PLUSONE}): Operator cost adjustment type. No matter what this setting is, axioms will always be considered as actions of cost 0 by the heuristics that treat axioms as actions.<ul>
<li><code>NORMAL</code>: all actions are accounted for with their real cost</li>
<li><code>ONE</code>: all actions are accounted for as unit cost</li>
<li><code>PLUSONE</code>: all actions are accounted for as their real cost + 1 (except if all actions have original cost 1, in which case cost 1 is used). This is the behaviour known for the heuristics of the LAMA planner. This is intended to be used by the heuristics, not search engines, but is supported for both.</li>
</ul>
</li>
<li><em>bound</em> (int): exclusive depth bound on g-values. Cutoffs are always performed according to the real cost, regardless of the cost_type parameter</li>
<li><em>max_time</em> (double): maximum time in seconds the search is allowed to run for. The timeout is only checked after each complete search step (usually a node expansion), so the actual runtime can be arbitrarily longer. Therefore, this parameter should not be used for time-limiting experiments. Timed-out searches are treated as failed searches, just like incomplete search algorithms that exhaust their search space.</li>
<li><em>verbosity</em> ({silent, normal, verbose, debug}): Option to specify the verbosity level.<ul>
<li><code>silent</code>: only the most basic output</li>
<li><code>normal</code>: relevant information to monitor progress</li>
<li><code>verbose</code>: full output</li>
<li><code>debug</code>: like full with additional debug output</li>
</ul>
</li>
</ul>
<p><strong>Open lists:</strong> In the general case, it uses an alternation open list with one queue for each evaluator h that ranks the nodes by g + w * h. If preferred operator evaluators are used, it adds for each of the evaluators another such queue that only inserts nodes that are generated by preferred operators. In the special case with only one evaluator and no preferred operator evaluators, it uses a single queue that is ranked by g + w * h. </p>
<h3 id="equivalent_statements_using_general_lazy_search_1">Equivalent statements using general lazy search<a class="headerlink" href="#equivalent_statements_using_general_lazy_search_1" title="Permanent link">#</a></h3>
<pre><code>--evaluator h1=eval1
--search lazy_wastar([h1, eval2], w=2, preferred=h1,
                     bound=100, boost=500)
</code></pre>
<p>is equivalent to</p>
<pre><code>--evaluator h1=eval1 --heuristic h2=eval2
--search lazy(alt([single(sum([g(), weight(h1, 2)])),
                   single(sum([g(), weight(h1, 2)]), pref_only=true),
                   single(sum([g(), weight(h2, 2)])),
                   single(sum([g(), weight(h2, 2)]), pref_only=true)],
                  boost=500),
              preferred=h1, reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar([eval1, eval2], w=2, bound=100)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(sum([g(), weight(eval1, 2)])),
                   single(sum([g(), weight(eval2, 2)]))],
                  boost=1000),
              reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar([eval1, eval2], bound=100, boost=0)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(alt([single(sum([g(), eval1])),
                   single(sum([g(), eval2]))])
              reopen_closed=true, bound=100)
</code></pre>
<hr />
<pre><code>--search lazy_wastar(eval1, w=2)
</code></pre>
<p>is equivalent to</p>
<pre><code>--search lazy(single(sum([g(), weight(eval1, 2)])), reopen_closed=true)
</code></pre>
<p><strong>Successor ordering:</strong> When using randomize_successors=true and preferred_successors_first=true, randomization happens before preferred operators are moved to the front.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../PruningMethod/" class="md-footer__link md-footer__link--prev" aria-label="Previous: PruningMethod" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              PruningMethod
            </div>
          </div>
        </a>
      
      
        
        <a href="../ShrinkStrategy/" class="md-footer__link md-footer__link--next" aria-label="Next: ShrinkStrategy" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              ShrinkStrategy
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.f8263e09.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.4fc53ad4.min.js"></script>
      
    
  </body>
</html>